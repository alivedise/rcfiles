.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::INI::Reader 3"
.TH Config::INI::Reader 3 "2008-06-05" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Config::INI::Reader \- a subclassable .ini\-file parser
.SH "VERSION"
.IX Header "VERSION"
version 0.013
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
If \fIfamily.ini\fR contains:
.PP
.Vb 1
\&  admin = rjbs
.Ve
.PP
.Vb 3
\&  [rjbs]
\&  awesome = yes
\&  height = 5' 10"
.Ve
.PP
.Vb 3
\&  [mj]
\&  awesome = totally
\&  height = 23"
.Ve
.PP
Then when your program contains:
.PP
.Vb 1
\&  my $hash = Config::INI::Reader->read_file('family.ini');
.Ve
.PP
\&\f(CW$hash\fR will contain:
.PP
.Vb 11
\&  {
\&    '_'  => { admin => 'rjbs' },
\&    rjbs => {
\&      awesome => 'yes',
\&      height  => q{5' 10"},
\&    },
\&    mj   => {
\&      awesome => 'totally',
\&      height  => '23"',
\&    },
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Config::INI::Reader is \fIyet another\fR config module implementing \fIyet another\fR
slightly different take on the undeniably easy to read \*(L".ini\*(R" file format.  Its default behavior is quite similar to that of
Config::Tiny, on which it is based.
.PP
The chief difference is that Config::INI::Reader is designed to be subclassed
to allow for side-effects and self-reconfiguration to occur during the course
of reading its input.
.SH "METHODS FOR READING CONFIG"
.IX Header "METHODS FOR READING CONFIG"
These methods are all that most users will need: they read configuration from a
source of input, then they return the data extracted from that input.  There
are three reader methods, \f(CW\*(C`read_string\*(C'\fR, \f(CW\*(C`read_file\*(C'\fR, and \f(CW\*(C`read_handle\*(C'\fR.
The first two are implemented in terms of the third.  It iterates over lines in
a file, calling methods on the reader when events occur.  Those events are
detailed below in the \*(L"\s-1METHODS\s0 \s-1FOR\s0 \s-1SUBCLASSING\s0\*(R" section.
.PP
All of the reader methods return an unblessed reference to a hash.
.PP
All throw an exception when they encounter an error.
.Sh "read_file"
.IX Subsection "read_file"
.Vb 1
\&  my $hash_ref = Config::INI::Reader->read($filename);
.Ve
.PP
Given a filename, this method returns a hashref of the contents of that file.
.Sh "read_string"
.IX Subsection "read_string"
.Vb 1
\&  my $hash_ref = Config::INI::Reader->read_string($string);
.Ve
.PP
Given a string, this method returns a hashref of the contents of that string.
.Sh "read_handle"
.IX Subsection "read_handle"
.Vb 1
\&  my $hash_ref = Config::INI::Reader->read_handle($io_handle);
.Ve
.PP
Given an IO::Handle, this method returns a hashref of the contents of that
handle.
.SH "METHODS FOR SUBCLASSING"
.IX Header "METHODS FOR SUBCLASSING"
These are the methods you need to understand and possibly change when
subclassing Config::INI::Reader to handle a different format of input.
.Sh "current_section"
.IX Subsection "current_section"
.Vb 1
\&  my $section_name = $reader->current_section;
.Ve
.PP
This method returns the name of the current section.  If no section has yet
been set, it returns the result of calling the \f(CW\*(C`starting_section\*(C'\fR method.
.Sh "parse_section_header"
.IX Subsection "parse_section_header"
.Vb 1
\&  my $name = $reader->parse_section_header($line);
.Ve
.PP
Given a line of input, this method decides whether the line is a section-change
declaration.  If it is, it returns the name of the section to which to change.
If the line is not a section\-change, the method returns false.
.Sh "change_section"
.IX Subsection "change_section"
.Vb 1
\&  $reader->change_section($section_name);
.Ve
.PP
This method is called whenever a section change occurs in the file.
.PP
The default implementation is to change the current section into which data is
being read and to initialize that section to an empty hashref.
.Sh "parse_value_assignment"
.IX Subsection "parse_value_assignment"
.Vb 1
\&  my ($name, $value) = $reader->parse_value_assignment($line);
.Ve
.PP
Given a line of input, this method decides whether the line is a property
value assignment.  If it is, it returns the name of the property and the value
being assigned to it.  If the line is not a property assignment, the method
returns false.
.Sh "set_value"
.IX Subsection "set_value"
.Vb 1
\&  $reader->set_value($name, $value);
.Ve
.PP
This method is called whenever an assignment occurs in the file.  The default
behavior is to change the value of the named property to the given value.
.Sh "starting_section"
.IX Subsection "starting_section"
.Vb 1
\&  my $section = Config::INI::Reader->starting_section;
.Ve
.PP
This method returns the name of the starting section.  The default is: \f(CW\*(C`_\*(C'\fR
.Sh "can_ignore"
.IX Subsection "can_ignore"
.Vb 1
\&  do_nothing if $reader->can_ignore($line)
.Ve
.PP
This method returns true if the given line of input is safe to ignore.  The
default implementation ignores lines that contain only whitespace or comments.
.Sh "preprocess_line"
.IX Subsection "preprocess_line"
.Vb 1
\&  $reader->preprocess_line(\e$line);
.Ve
.PP
This method is called to preprocess each line after it's read but before it's
parsed.  The default implementation just strips inline comments.  Alterations
to the line are made in place.
.Sh "finalize"
.IX Subsection "finalize"
.Vb 1
\&  $reader->finalize;
.Ve
.PP
This method is called when the reader has finished reading in every line of the
file.
.Sh "new"
.IX Subsection "new"
.Vb 1
\&  my $reader = Config::INI::Reader->new;
.Ve
.PP
This method returns a new reader.  This generally does not need to be called by
anything but the various \f(CW\*(C`read_*\*(C'\fR methods, which create a reader object only
ephemerally.
.SH "TODO"
.IX Header "TODO"
.IP "* more tests" 4
.IX Item "more tests"
.SH "BUGS"
.IX Header "BUGS"
Bugs should be reported via the \s-1CPAN\s0 bug tracker at
.PP
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Config\-INI>
.PP
For other issues, or commercial enhancement or support, contact the author.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ricardo \s-1SIGNES\s0, \f(CW\*(C`<rjbs@cpan.org>\*(C'\fR
.PP
Originaly derived from Config::Tiny, by Adam Kennedy.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2007, Ricardo \s-1SIGNES\s0.
.PP
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
