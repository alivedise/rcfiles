.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Std 3"
.TH Config::Std 3 "2006-02-20" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Config::Std \- Load and save configuration files in a standard format
.SH "VERSION"
.IX Header "VERSION"
This document describes Config::Std version 0.0.4
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Config::Std;
.Ve
.PP
.Vb 2
\&    # Load named config file into specified hash...
\&    read_config 'demo2.cfg' => my %config;
.Ve
.PP
.Vb 2
\&    # Extract the value of a key/value pair from a specified section...
\&    $config_value = $config{Section_label}{key};
.Ve
.PP
.Vb 2
\&    # Change (or create) the value of a key/value pair...
\&    $config{Other_section_label}{other_key} = $new_val;
.Ve
.PP
.Vb 2
\&    # Update the config file from which this hash was loaded...
\&    write_config %config;
.Ve
.PP
.Vb 2
\&    # Write the config information to another file as well...
\&    write_config %config, $other_file_name;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements yet another damn configuration-file system.
.PP
The configuration language is deliberately simple and limited, and the
module works hard to preserve as much information (section order,
comments, etc.) as possible when a configuration file is updated.
.PP
See Chapter 19 of \*(L"Perl Best Practices\*(R" (O'Reilly, 2005) for the
rationale for this approach.
.Sh "Configuration language"
.IX Subsection "Configuration language"
The configuration language is a slight extension of the Windows \s-1INI\s0 format.
.PP
\fIComments\fR
.IX Subsection "Comments"
.PP
A comment starts with a \f(CW\*(C`#\*(C'\fR character and runs to the end of the same line:
.PP
.Vb 1
\&    # This is a comment
.Ve
.PP
Comments can be placed almost anywhere in a configuration file, except inside
a section label, or in the key or value of a configuration variable:
.PP
.Vb 2
\&    # Valid comment
\&    [ # Not a comment, just a weird section label ]
.Ve
.PP
.Vb 2
\&    # Valid comment
\&    key: value  # Not a comment, just part of the value
.Ve
.PP
\fISections\fR
.IX Subsection "Sections"
.PP
A configuration file consists of one or more \fIsections\fR, each of which is
introduced by a label in square brackets:
.PP
.Vb 1
\&    [SECTION1]        # Almost anything is a valid section label
.Ve
.PP
.Vb 1
\&    [SECTION 2]       # Internal whitespace is allowed (except newlines)
.Ve
.PP
.Vb 1
\&    [%^$%^&!!!]       # The label doesn't have to be alphanumeric
.Ve
.PP
.Vb 1
\&    [ETC. ETC. AS MANY AS YOU WANT]
.Ve
.PP
The only restriction on section labels is that they must be by
themselves on a single line (except for any surrounding whitespace or
trailing comments), and they cannot contain the character \f(CW\*(C`]\*(C'\fR.
.PP
Every line after a given section label until the next section label (or
the end of the config file) belongs to the given section label. If no
section label is currently in effect, the current section has an empty
label. In other words, there is an implicit:
.PP
.Vb 1
\&    []                # Label is the empty string
.Ve
.PP
at the start of each config file.
.PP
\fIConfiguration variables\fR
.IX Subsection "Configuration variables"
.PP
Each non-empty line within a section must consist of the specification of a
\&\fIconfiguration variable\fR. Each such variable consists of a key and a string
value. For example:
.PP
.Vb 2
\&    name: George
\&     age: 47
.Ve
.PP
.Vb 1
\&    his weight! : 185
.Ve
.PP
The key consists of every character (including internal whitespace) from
the start of the line until the key/value separator. So, the previous
example declares three keys: \f(CW'name'\fR, \f(CW'age'\fR, and \f(CW'his weight!'\fR.
.PP
Note that whitespace before and after the key is removed. This makes it easier
to format keys cleanly:
.PP
.Vb 3
\&           name : George
\&            age : 47
\&    his weight! : 185
.Ve
.PP
The key/value separator can be either a colon (as above) or an equals sign,
like so:
.PP
.Vb 3
\&           name= George
\&            age=  47
\&    his weight! = 185
.Ve
.PP
Both types of separators can be used in the same file, but neither can
be used as part of a key. Newlines are not allowed in keys either.
.PP
When writing out a config file, Config::Std tries to preserve whichever
separator was used in the original data (if that data was read
in). New data is written back with a colon as its default separator,
unless you specify otherwise when the module is loaded:
.PP
.Vb 1
\&    use Config::Std { def_sep => '=' };
.Ve
.PP
Everything from the first non-whitespace character after the separator,
up to the end of the line, is treated as the value for the config variable.
So all of the above examples define the same three values: \f(CW'George'\fR,
\&\f(CW'47'\fR, and \f(CW'185'\fR.
.PP
In other words, any whitespace immediately surrounding the separator
character is part of the separator, not part of the key or value.
.PP
Note that you can't put a comment on the same line as a configuration
variable. The \f(CW\*(C`# etc.\*(C'\fR is simply considered part of the value:
.PP
.Vb 1
\&    [Delimiters]
.Ve
.PP
.Vb 3
\&    block delims:    { }
\&    string delims:   " "
\&    comment delims:  # \en
.Ve
.PP
You can comment a config var on the preceding or succeeding line:
.PP
.Vb 1
\&    [Delimiters]
.Ve
.PP
.Vb 2
\&    # Use braces to delimit blocks...
\&    block delims:    { }
.Ve
.PP
.Vb 1
\&    # Use double quotes to delimit strings
.Ve
.PP
.Vb 1
\&    string delims:   " "
.Ve
.PP
.Vb 2
\&    # Use octothorpe/newline to delimit comments
\&    comment delims:  # \en
.Ve
.PP
\fIMulti-line configuration values\fR
.IX Subsection "Multi-line configuration values"
.PP
A single value can be continued over two or more lines. If the line
immediately after a configuration variable starts with the separator
character used in the variable's definition, then the value of the
variable continues on that line. For example:
.PP
.Vb 3
\&    address: 742 Evergreen Terrace
\&           : Springfield
\&           : USA
.Ve
.PP
The newlines then form part of the value, so the value specified in the
previous example is: \f(CW\*(C`\*(L"742\ Evergreen\ Terrace\enSpringfield\enUSA\*(R"\*(C'\fR
.PP
Note that the second and subsequent lines of a continued value are considered
to start where the whitespace after the \fIoriginal\fR separator finished, not
where the whitespace after their own separator finishes. For example, if the
previous example had been:
.PP
.Vb 3
\&    address: 742 Evergreen Terrace
\&           :   Springfield
\&           :     USA
.Ve
.PP
then the value would be:
.PP
.Vb 1
\&    "742 Evergreen Terrace\en  Springfield\en    USA"
.Ve
.PP
If a continuation line has less leading whitespace that the first line:
.PP
.Vb 3
\&    address:   742 Evergreen Terrace
\&           :  Springfield
\&           : USA
.Ve
.PP
it's treated as having no leading whitespace:
.PP
.Vb 1
\&    "742 Evergreen Terrace\enSpringfield\enUSA"
.Ve
.PP
\fIMulti-part configuration values\fR
.IX Subsection "Multi-part configuration values"
.PP
If the particular key appears more than once in the same section, it is
considered to be part of the same configuration variable. The value of
that configuration value is then a list, containing all the individual
values for each instance of the key. For example, given the definition:
.PP
.Vb 5
\&    cast: Homer
\&    cast: Marge
\&    cast: Lisa
\&    cast: Bart
\&    cast: Maggie
.Ve
.PP
the corresponding value of the \f(CW'cast'\fR configuration variable is:
\&\f(CW\*(C`['Homer',\ 'Marge',\ 'Lisa',\ 'Bart',\ 'Maggie']\*(C'\fR
.PP
Individual values in a multi-part list can also be multi-line (see
above). For example, given:
.PP
.Vb 2
\&    extras: Moe
\&          : (the bartender)
.Ve
.PP
.Vb 2
\&    extras: Smithers
\&          : (the dogsbody)
.Ve
.PP
the value for the \f(CW'extras'\fR config variable is:
\&\f(CW\*(C`[\*(L"Moe\en(the\ bartender)\*(R",\ \*(L"Smithers\en(the\ dogsbody)\*(R"]\*(C'\fR
.Sh "Internal representation"
.IX Subsection "Internal representation"
Each section label in a configuration file becomes a top-level hash key whe
the configuration file is read in. The corresponding value is a nested hash
reference.
.PP
Each configuration variable's key becomes a key in that nested hash reference.
Each configuration variable's value becomes the corresponding value in that nested hash reference.
.PP
Single-line and multi-line values become strings. Multi-part values become
references to arrays of strings.
.PP
For example, the following configuration file:
.PP
.Vb 2
\&    # A simple key (just an identifier)...
\&    simple : simple value
.Ve
.PP
.Vb 2
\&    # A more complex key (with whitespace)...
\&    more complex key : more complex value
.Ve
.PP
.Vb 2
\&    # A new section...
\&    [MULTI-WHATEVERS]
.Ve
.PP
.Vb 4
\&    # A value spread over several lines...
\&    multi-line : this is line 1
\&               : this is line 2
\&               : this is line 3
.Ve
.PP
.Vb 4
\&    # Several values for the same key...
\&    multi-value: this is value 1
\&    multi-value: this is value 2
\&    multi-value: this is value 3
.Ve
.PP
would be read into a hash whose internal structure looked like this:
.PP
.Vb 6
\&    {
\&       # Default section...
\&       '' => {
\&          'simple'           => 'simple value',
\&          'more complex key' => 'more complex value',
\&       },
.Ve
.PP
.Vb 3
\&       # Named section...
\&       'MULTI-WHATEVERS' => {
\&            'multi-line'  => "this is line 1\enthis is line 2\enthis is line 3",
.Ve
.PP
.Vb 6
\&            'multi-value' => [ 'this is value 1',
\&                               'this is value 2',
\&                               'this is value 3'
\&                             ],
\&        }
\&    }
.Ve
.SH "INTERFACE"
.IX Header "INTERFACE"
The following subroutines are exported automatically whenever the module is
loaded...
.ie n .IP """read_config($filename => %config_hash)""" 4
.el .IP "\f(CWread_config($filename => %config_hash)\fR" 4
.IX Item "read_config($filename => %config_hash)"
.PD 0
.ie n .IP """read_config($filename => $config_hash_ref)""" 4
.el .IP "\f(CWread_config($filename => $config_hash_ref)\fR" 4
.IX Item "read_config($filename => $config_hash_ref)"
.PD
The \f(CW\*(C`read_config()\*(C'\fR subroutine takes two arguments: the filename of a
configuration file, and a variable into which the contents of that
configuration file are to be loaded.
.Sp
If the variable is a hash, then the configuration sections and their
key/value pairs are loaded into nested subhashes of the hash.
.Sp
If the variable is a scalar with an undefined value, a reference to an
anonymous hash is first assigned to that scalar, and that hash is then
filled as described above.
.Sp
The subroutine returns true on success, and throws an exception on failure.
.ie n .IP """write_config(%config_hash => $filename)""" 4
.el .IP "\f(CWwrite_config(%config_hash => $filename)\fR" 4
.IX Item "write_config(%config_hash => $filename)"
.PD 0
.ie n .IP """write_config($config_hash_ref => $filename)""" 4
.el .IP "\f(CWwrite_config($config_hash_ref => $filename)\fR" 4
.IX Item "write_config($config_hash_ref => $filename)"
.ie n .IP """write_config(%config_hash)""" 4
.el .IP "\f(CWwrite_config(%config_hash)\fR" 4
.IX Item "write_config(%config_hash)"
.ie n .IP """write_config($config_hash_ref)""" 4
.el .IP "\f(CWwrite_config($config_hash_ref)\fR" 4
.IX Item "write_config($config_hash_ref)"
.PD
The \f(CW\*(C`write_config()\*(C'\fR subroutine takes two arguments: the hash or hash
reference containing the configuration data to be written out to disk,
and an optional filename specifying which file it is to be written to.
.Sp
The data hash must conform to the two-level structure described earlier:
with top-level keys naming sections and their values being references to
second-level hashes that store the keys and values of the configuartion
variables. If the structure of the hash differs from this, an exception is
thrown.
.Sp
If a filename is also specified, the subroutine opens that file
and writes to it. It no filename is specified, the subroutine uses the
name of the file from which the hash was originally loaded using
\&\f(CW\*(C`read_config()\*(C'\fR. It no filename is specified and the hash \fIwasn't\fR
originally loaded using \f(CW\*(C`read_config()\*(C'\fR, an exception is thrown.
.Sp
The subroutine returns true on success and throws and exception on failure.
.PP
If necessary (typically to avoid conflicts with other modules), you can
have the module export its two subroutines with different names by
loading it with the appropriate options:
.PP
.Vb 1
\&    use Config::Std { read_config => 'get_ini', write_config => 'update_ini' };
.Ve
.PP
.Vb 1
\&    # and later...
.Ve
.PP
.Vb 1
\&    get_ini($filename => %config_hash);
.Ve
.PP
.Vb 1
\&    # and later still...
.Ve
.PP
.Vb 1
\&    update_ini(%config_hash);
.Ve
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.IP "Can't open config file '%s' (%s)" 4
.IX Item "Can't open config file '%s' (%s)"
You tried to read in a configuration file, but the file you specified
didn't exist. Perhaps the filepath you specified was wrong. Or maybe 
your application didn't have permission to access the file you specified.
.IP "Can't read from locked config file '$filename'" 4
.IX Item "Can't read from locked config file '$filename'"
You tried to read in a configuration file, but the file you specified
was being written by someone else (they had a file lock active on it).
Either try again later, or work out who else is using the file.
.IP "Scalar second argument to 'read_config' must be empty" 4
.IX Item "Scalar second argument to 'read_config' must be empty"
You passed a scalar variable as the destination into \f(CW\*(C`read_config()\*(C'\fR
was supposed to load a configuration file, but that variable already had
a defined value, so \f(CW\*(C`read_config()\*(C'\fR couldn't autovivify a new hash for
you. Did you mean to pass the subroutine a hash instead of a scalar?
.ie n .IP "Can't save %s value for key '%s' (only scalars or array refs)" 4
.el .IP "Can't save \f(CW%s\fR value for key '%s' (only scalars or array refs)" 4
.IX Item "Can't save %s value for key '%s' (only scalars or array refs)"
You called \f(CW\*(C`write_config\*(C'\fR and passed it a hash containing a
configuration variable whose value wasn't a single string, or a list of
strings. The configuration file format supported by this module only
supports those two data types as values. If you really need to store
other kinds of data in a configuration file, you should consider using
\&\f(CW\*(C`Data::Dumper\*(C'\fR or \f(CW\*(C`YAML\*(C'\fR instead.
.IP "Missing filename in call to \fIwrite_config()\fR" 4
.IX Item "Missing filename in call to write_config()"
You tried to calll \f(CW\*(C`write_config()\*(C'\fR with only a configuration hash, but that
hash wasn't originally loaded using \f(CW\*(C`read_config()\*(C'\fR, so \f(CW\*(C`write_config()\*(C'\fR has
no idea where to write it to. Either make sure the hash you're trying to save
was originally loaded using \f(CW\*(C`read_config()\*(C'\fR, or else provide an explicit
filename as the second argument to \f(CW\*(C`write_config()\*(C'\fR.
.IP "Can't open config file '%s' for writing (%s)" 4
.IX Item "Can't open config file '%s' for writing (%s)"
You tried to update or create a configuration file, but the file you
specified could not be opened for writing (for the reason given in the
parentheses). This is often caused by incorrect filepaths or lack of
write permissions on a directory.
.IP "Can't write to locked config file '%s'" 4
.IX Item "Can't write to locked config file '%s'"
You tried to update or create a configuration file, but the file you
specified was being written at the time by someone else (they had a file
lock active on it). Either try again later, or work out who else is
using the file.
.SH "CONFIGURATION AND ENVIRONMENT"
.IX Header "CONFIGURATION AND ENVIRONMENT"
Config::Std requires no configuration files or environment variables.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
This module requires the Class::Std module (available from the \s-1CPAN\s0)
.SH "INCOMPATIBILITIES"
.IX Header "INCOMPATIBILITIES"
None reported.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
No bugs have been reported.
.PP
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-config\-std@rt.cpan.org\*(C'\fR, or through the web interface at
<http://rt.cpan.org>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway  \f(CW\*(C`<DCONWAY@cpan.org>\*(C'\fR
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2005, Damian Conway \f(CW\*(C`<DCONWAY@cpan.org>\*(C'\fR. All rights reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "DISCLAIMER OF WARRANTY"
.IX Header "DISCLAIMER OF WARRANTY"
\&\s-1BECAUSE\s0 \s-1THIS\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1LICENSED\s0 \s-1FREE\s0 \s-1OF\s0 \s-1CHARGE\s0, \s-1THERE\s0 \s-1IS\s0 \s-1NO\s0 \s-1WARRANTY\s0
\&\s-1FOR\s0 \s-1THE\s0 \s-1SOFTWARE\s0, \s-1TO\s0 \s-1THE\s0 \s-1EXTENT\s0 \s-1PERMITTED\s0 \s-1BY\s0 \s-1APPLICABLE\s0 \s-1LAW\s0. \s-1EXCEPT\s0 \s-1WHEN\s0
\&\s-1OTHERWISE\s0 \s-1STATED\s0 \s-1IN\s0 \s-1WRITING\s0 \s-1THE\s0 \s-1COPYRIGHT\s0 \s-1HOLDERS\s0 \s-1AND/OR\s0 \s-1OTHER\s0 \s-1PARTIES\s0
\&\s-1PROVIDE\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \*(L"\s-1AS\s0 \s-1IS\s0\*(R" \s-1WITHOUT\s0 \s-1WARRANTY\s0 \s-1OF\s0 \s-1ANY\s0 \s-1KIND\s0, \s-1EITHER\s0
\&\s-1EXPRESSED\s0 \s-1OR\s0 \s-1IMPLIED\s0, \s-1INCLUDING\s0, \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0, \s-1THE\s0 \s-1IMPLIED\s0
\&\s-1WARRANTIES\s0 \s-1OF\s0 \s-1MERCHANTABILITY\s0 \s-1AND\s0 \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0. \s-1THE\s0
\&\s-1ENTIRE\s0 \s-1RISK\s0 \s-1AS\s0 \s-1TO\s0 \s-1THE\s0 \s-1QUALITY\s0 \s-1AND\s0 \s-1PERFORMANCE\s0 \s-1OF\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1WITH\s0
\&\s-1YOU\s0. \s-1SHOULD\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1PROVE\s0 \s-1DEFECTIVE\s0, \s-1YOU\s0 \s-1ASSUME\s0 \s-1THE\s0 \s-1COST\s0 \s-1OF\s0 \s-1ALL\s0
\&\s-1NECESSARY\s0 \s-1SERVICING\s0, \s-1REPAIR\s0, \s-1OR\s0 \s-1CORRECTION\s0.
.PP
\&\s-1IN\s0 \s-1NO\s0 \s-1EVENT\s0 \s-1UNLESS\s0 \s-1REQUIRED\s0 \s-1BY\s0 \s-1APPLICABLE\s0 \s-1LAW\s0 \s-1OR\s0 \s-1AGREED\s0 \s-1TO\s0 \s-1IN\s0 \s-1WRITING\s0
\&\s-1WILL\s0 \s-1ANY\s0 \s-1COPYRIGHT\s0 \s-1HOLDER\s0, \s-1OR\s0 \s-1ANY\s0 \s-1OTHER\s0 \s-1PARTY\s0 \s-1WHO\s0 \s-1MAY\s0 \s-1MODIFY\s0 \s-1AND/OR\s0
\&\s-1REDISTRIBUTE\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1AS\s0 \s-1PERMITTED\s0 \s-1BY\s0 \s-1THE\s0 \s-1ABOVE\s0 \s-1LICENCE\s0, \s-1BE\s0
\&\s-1LIABLE\s0 \s-1TO\s0 \s-1YOU\s0 \s-1FOR\s0 \s-1DAMAGES\s0, \s-1INCLUDING\s0 \s-1ANY\s0 \s-1GENERAL\s0, \s-1SPECIAL\s0, \s-1INCIDENTAL\s0,
\&\s-1OR\s0 \s-1CONSEQUENTIAL\s0 \s-1DAMAGES\s0 \s-1ARISING\s0 \s-1OUT\s0 \s-1OF\s0 \s-1THE\s0 \s-1USE\s0 \s-1OR\s0 \s-1INABILITY\s0 \s-1TO\s0 \s-1USE\s0
\&\s-1THE\s0 \s-1SOFTWARE\s0 (\s-1INCLUDING\s0 \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0 \s-1LOSS\s0 \s-1OF\s0 \s-1DATA\s0 \s-1OR\s0 \s-1DATA\s0 \s-1BEING\s0
\&\s-1RENDERED\s0 \s-1INACCURATE\s0 \s-1OR\s0 \s-1LOSSES\s0 \s-1SUSTAINED\s0 \s-1BY\s0 \s-1YOU\s0 \s-1OR\s0 \s-1THIRD\s0 \s-1PARTIES\s0 \s-1OR\s0 A
\&\s-1FAILURE\s0 \s-1OF\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1TO\s0 \s-1OPERATE\s0 \s-1WITH\s0 \s-1ANY\s0 \s-1OTHER\s0 \s-1SOFTWARE\s0), \s-1EVEN\s0 \s-1IF\s0
\&\s-1SUCH\s0 \s-1HOLDER\s0 \s-1OR\s0 \s-1OTHER\s0 \s-1PARTY\s0 \s-1HAS\s0 \s-1BEEN\s0 \s-1ADVISED\s0 \s-1OF\s0 \s-1THE\s0 \s-1POSSIBILITY\s0 \s-1OF\s0
\&\s-1SUCH\s0 \s-1DAMAGES\s0.
